package com.marklogic.mgmt.resource.tasks;

import com.marklogic.mgmt.resource.AbstractResourceManager;
import com.marklogic.mgmt.ManageClient;
import com.marklogic.mgmt.resource.requests.RequestManager;
import com.marklogic.rest.util.Fragment;

import java.util.ArrayList;
import java.util.List;

/**
 * A scheduled task doesn't have a name, and the ID is generated by ML, so this class assumes that task-path will be
 * unique and can thus be used as a way to find an existing task.
 *
 * Note that the "groupName" property of this class corresponds to the "group-id" querystring parameter. It's called
 * "groupName" because "group-id" is misleading - it's a name, not an ID.
 */
public class TaskManager extends AbstractResourceManager {

	private String groupName = "Default";

	public TaskManager(ManageClient client) {
		super(client);
	}

	public TaskManager(ManageClient client, String groupName) {
		super(client);
		this.groupName = groupName;
	}

	@Override
	public String getResourcesPath() {
		return appendGroupId(super.getResourcesPath());
	}

	protected String appendGroupId(String path) {
		if (groupName != null) {
			if (path.contains("?")) {
				return path + "&group-id=" + groupName;
			}
			return path + "?group-id=" + groupName;
		}
		return path;
	}

	@Override
	public String getResourcePath(String resourceNameOrId, String... resourceUrlParams) {
		return super.getResourcesPath() + "/" + getTaskIdForTaskPath(resourceNameOrId);
	}

	@Override
	protected String[] getUpdateResourceParams(String payload) {
		List<String> params = new ArrayList<>();
		params.add("group-id");
		params.add(groupName);
		return params.toArray(new String[]{});
	}

	@Override
	protected String getIdFieldName() {
		return "task-path";
	}

	public String getTaskIdForTaskPath(String taskPath) {
		Fragment f = getAsXml();
		String xpath = "/node()/*[local-name(.) = 'list-items']/node()"
			+ "[*[local-name(.) = 'task-path'] = '%s']/*[local-name(.) = 'idref']";
		xpath = String.format(xpath, taskPath);
		String id = f.getElementValue(xpath);
		if (id == null) {
			throw new RuntimeException("Could not find a scheduled task with a task-path of: " + taskPath);
		}
		return id;
	}

	@Override
	public boolean exists(String resourceNameOrId, String... resourceUrlParams) {
		if (logger.isInfoEnabled()) {
			logger.info("Checking for existence of resource: " + resourceNameOrId);
		}
		Fragment f = getAsXml();
		return f.elementExists(format(
			"/node()/*[local-name(.) = 'list-items']/node()[*[local-name(.) = 'task-path'] = '%s']",
			resourceNameOrId));
	}

	public List<String> getTaskPaths() {
		return getAsXml().getListItemValues("task-path");
	}

	public void disableAllTasks() {
		for (String id : getAsXml().getListItemIdRefs()) {
			disableTask(id);
		}
	}

	public void enableAllTasks() {
		for (String id : getAsXml().getListItemIdRefs()) {
			enableTask(id);
		}
	}

	public void disableTask(String taskId) {
		String json = format("{\"task-id\":\"%s\", \"task-enabled\":false}", taskId);
		String path = appendGroupId(super.getResourcesPath() + "/" + taskId + "/properties");
		putPayload(getManageClient(), path, json);
	}

	public void enableTask(String taskId) {
		String json = format("{\"task-id\":\"%s\", \"task-enabled\":true}", taskId);
		String path = appendGroupId(super.getResourcesPath() + "/" + taskId + "/properties");
		putPayload(getManageClient(), path, json);
	}

	public void deleteAllTasks() {
		deleteAllScheduledTasks();
	}

	public void deleteTaskWithPath(String taskPath) {
		String json = format("{\"task-path\":\"%s\"}", taskPath);
		delete(json, "group-id", groupName);
	}

	public String getTaskId(String taskPath) {
		return getAsXml().getElementValue(format(
			"/t:tasks-default-list/t:list-items/t:list-item[t:task-path = '%s']/t:idref", taskPath)
		);
	}

	public void deleteAllScheduledTasks() {
		for (String id : getAsXml().getListItemIdRefs()) {
			deleteAtPath(appendGroupId(super.getResourcesPath() + "/" + id));
		}
	}

	public void waitForTasksToComplete(String group, int retryInMilliseconds) {
		Fragment servers = getManageClient().getXml("/manage/v2/task-servers");
		String taskServerId = servers.getElementValue(format("//ts:list-item[ts:groupnameref = '%s']/ts:idref", group));
		if (taskServerId == null) {
			logger.warn(format("Could not find task server ID for group %s, so not waiting for tasks to complete", group));
			return;
		}
		RequestManager mgr = new RequestManager(getManageClient());
		if (logger.isInfoEnabled()) {
			logger.info("Waiting for tasks to complete on task server");
		}
		int count = mgr.getRequestCountForRelationId(taskServerId);
		while (count > 0) {
			if (logger.isInfoEnabled()) {
				logger.info("Waiting for tasks to complete on task server, count: " + count);
			}
			try {
				Thread.sleep(retryInMilliseconds);
			} catch (InterruptedException e) {
			}
			count = mgr.getRequestCountForRelationId(taskServerId);
		}
		if (logger.isInfoEnabled()) {
			logger.info("Finished waiting for tasks to complete on task server");
		}
	}

	public void setGroupName(String groupName) {
		this.groupName = groupName;
	}

	public String getGroupName() {
		return groupName;
	}
}
